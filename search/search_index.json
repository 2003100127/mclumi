{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome_to_the_homepage_of_mclumi","title":"Welcome to the homepage of mclUMI!","text":"<p>What is it?</p> <p>For UMI collapsing/deduplication to improve molecular quantification accuracy.</p> <p>mclUMI is a toolkit developed by using the Markov clustering (MCL) network-based algorithm for correcting UMI errors and thus precisely counting unique UMIs. Dynamic counting results feature the tool. mclUMI is implemented with Python.</p> Fig 1. Schematic of mclUMI for UMI deduplication"},{"location":"#features","title":"Features","text":"<p>There is a summary for technical features of mclUMI.</p> <p>Technical features</p> <p>It provides 4 modules for UMI deduplication, including </p> <pre><code>dedup_basic, dedup_pos, dedup_gene, and dedup_sc\n</code></pre> <p>Each module for UMI deduplication includes 7 algorithms</p> <pre><code>mcl, mcl_ed, mcl_val, unique, cluster, adjacency, and directional\n</code></pre> <p>Each takes as input the alignment result in a bam file and outputs a UMI-deduplicated alignment in a new bam file and another 2 summary files.</p> <ul> <li> Algorithm category<ul> <li> Graph-based UMI collapsing</li> <li> Euclidean distance-based UMI collapsing</li> </ul> </li> <li> Installation package<ul> <li> PyPI</li> <li> Conda</li> <li> Docker</li> <li> Github</li> </ul> </li> <li> Sequencing level<ul> <li> Single genomic locus</li> <li> Bulk RNA-seq</li> <li> single-cell (sc) RNA-seq</li> </ul> </li> </ul>"},{"location":"#programming","title":"Programming","text":"<p>mclUMI provides two user-friendly interfaces to run internally (Python inline) or externally (CLI).</p> <ul> <li><code>language</code> - Python</li> <li><code>module</code> - Object Oriented Programming (OOP)</li> <li><code>command</code> - Python and Shell</li> </ul> <p>In Python <pre><code>import mclumi as mu\n\nmu.onepos\nmu.multipos\nmu.gene\nmu.sc\n...\n</code></pre></p> <p>In Shell</p> <pre><code>$ mclumi [module | str] \\\n-m [method | str] \\\n-ed [edit distance | int]  \\\n-pfpn [yaml file | str] \\\n-bfpn [bam file | str] \\\n-wd [output path | str] \\\n-vb [if verbose | boolean]\n</code></pre>"},{"location":"about/","title":"About","text":"<p>We are a computational team at the University of Oxford to develop mathematical modelss and artificial intelligent tools to better interpret biology.</p>"},{"location":"contact/","title":"Contact","text":"<ul> <li> Developer: Dr. Jianfeng Sun</li> <li> Contributor: Dr. Jianfeng Sun and Prof. Adam P. Cribbs</li> <li> Lab: Prof. Cribbs' Group | Computational and Systems Biology</li> <li> Affiliation: Nuffield Department of Orthopaedics, Rheumatology and Musculoskeletal Sciences (NDORMS), Headington, Oxford OX3 7LD, University of Oxford.</li> <li> Email: Jianfeng.sun@ndorms.ox.ac.uk; jianfeng.sunmt@gmail.com; adam.cribbs@ndorms.ox.ac.uk</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#system_requirement","title":"System Requirement","text":"<p>There is no requirement for mclUMI, a cross-platform package.</p>"},{"location":"installation/#pypi","title":"PyPI","text":"<p>mclumi homepage on PyPI</p> <pre><code># create a conda environment\nconda create --name mclumi python=3.11\n\n# activate the conda environment\nconda activate mclumi\n\n# the latest version\npip install mclumi --upgrade\n</code></pre>"},{"location":"installation/#conda","title":"Conda","text":"<p>mclumi homepage on Anaconda</p> <pre><code># create a conda environment\nconda create --name mclumi python=3.11\n\n# activate the conda environment\nconda activate mclumi\n\n# the latest version\nconda install jianfeng_sun::mclumi\n</code></pre>"},{"location":"installation/#docker","title":"Docker","text":"<p>mclumi homepage on Docker</p> <pre><code>docker pull 2003100127/mclumi\n</code></pre>"},{"location":"installation/#github","title":"Github","text":"<p>mclumi homepage on Github</p> <pre><code># create a conda environment\nconda create --name mclumi python=3.11\n\n# activate the conda environment\nconda activate mclumi\n\n# create a folder\nmkdir project\n\n# go to the folder\ncd project\n\n# fetch mclUMI repository with the latest version\ngit clone https://github.com/2003100127/mclumi.git\n\n# enter this repository\ncd mclumi\n\n# do the following command\npip install .\n# or\npython setup.py install\n</code></pre>"},{"location":"tutorial/Quick%20start/","title":"Quick start","text":"<p>We set up a quick start here to guide you through an example to use mclUMI for UMI deduplication. Every module for this purpose in mclUMI provides 7 methods, that is, <code>unique</code>, <code>cluster</code>, <code>adjacency</code>, <code>directional</code>, <code>mcl</code>, <code>mcl_ed</code>, and <code>mcl_val</code> to handle precise unique UMI counting in the following application scenarios, 1). a single genomic locus, 2). multiple genomic loci, 3). genes, and 4). cell-by-gene types.</p> <p>We present a case study for UMI deduplication according to genomic positions. In mclUMI, <code>mclumi.multipos</code> is responsible for UMI deduplication according to genomic positions, which allows users to deduplicate PCR artifacts/UMIs based on a set of genomic position annotations. In the quick start guide, we omit data preprocessing procedures and start by directly using a dataset (a clip of ChIP-seq data used also in UMI-tools) containing 1,175,027 reads with 20,683 raw unique UMI sequences and 12,047 genomic positions by running the UMI-tools <code>get_bundles</code> method. This method is also adopted by mclUMI. For details, please refer to the <code>mclumi.prep.run</code> module.</p>"},{"location":"tutorial/Quick%20start/#install","title":"Install","text":"<pre><code>pip install mclumi --upgrade\n</code></pre>"},{"location":"tutorial/Quick%20start/#running","title":"Running","text":"<pre><code>import mclumi as mu\n\ndf_mcl = mu.multipos.mcl(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    pos_tag='PO',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl)\n</code></pre>"},{"location":"tutorial/Quick%20start/#result","title":"Result","text":"<p>After running, mclUMI generates two files for UMI deduplication statistics and one bam file for deduplicated reads. Please see details at 4 different UMI deduplication levels.</p> Fig 1. Average edit distance observed at multiple genomic positions Fig 2. Statistics of UMI deduplication using mclUMI <p>Comparison of <code>Directional</code> between mclUMI and UMI-tools</p> <p>The directional algorithm in the UMI-tools suite has been reported to achieve the best expectancy in identifying PCR duplicates. In mclUMI, we re-implemented the directional method to familiarize ourselves with the UMI deduplication and ensure our further optimization work based on the correct path. We then proposed a more flexible method based on Markov clustering. What does the output of the directional module in both UMI-tools (see also the results) and mclUMI look like? The same! Please see below. </p> Fig 3. Average edit distance distribution of genomic positions"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/","title":"1. Single locus","text":"<p><code>mclumi.onepos</code> is a module used for deduplicating UMIs observed at a single genomic locus or a single gene.</p>"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#usage","title":"Usage","text":"<p>The <code>mclumi.onepos</code> module can be used in Python and Shell.</p>"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#1_python","title":"1. Python","text":""},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#11_command","title":"1.1 Command","text":"MCLMCL-valMCL-edUniqueClusterAdjacencyDirectional <pre><code>import mclumi as mu\n\ndf_mcl = mu.onepos.mcl(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_mcl_val = mu.onepos.mcl_val(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    mcl_fold_thres=1.5,\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl_val)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_mcl_ed = mu.onepos.mcl_ed(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    mcl_fold_thres=1.5,\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl_ed)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_unique = mu.onepos.unique(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_unique)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_cluster = mu.onepos.cluster(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_cluster)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_adjacency = mu.onepos.adjacency(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_adjacency)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_directional = mu.onepos.directional(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_directional)\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#12_attributes_in_the_yaml_file","title":"1.2 Attributes in the YAML file","text":"<p>Illustration</p> Attribute Description <code>ed_thres</code> edit distance <code>bam_fpn</code> input file in the BAM format <code>heterogeneity</code> mode to indicate if studying trajectories of UMI origins and copies/derivatives across a series of PCR amplication cycles. If <code>heterogeneity</code> is set to <code>True</code>, users will gain more statistics and files in the final output directory <code>inflat_val</code> inflation parameter of the Markov Clustering algorithm <code>exp_val</code> expansion parameter of the Markov Clustering algorithm <code>iter_num</code> number of interations for the Markov Clustering algorithm to converge <code>mcl_fold_thres</code> a fold change threshold for MCL at a range of (1, <code>l</code>) where <code>l</code> is the length of a UMI. This parameter is placed when the <code>mcl_ed</code> or <code>mcl_val</code> function is used. <code>verbose</code> whether to print intermediate results"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#2_shell","title":"2. Shell","text":""},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#21_command","title":"2.1 Command","text":"<p>The shell command is simplified, but more parameters should be specified in a YAML file, <code>params.yml</code> in order to reduce complexity but optimise future extension. <pre><code>mclumi locus \\\n-m mcl \\\n-ed 1  \\\n-pfpn ./mclumi/data/params.yml \\\n-bfpn ./mclumi/data/example_bundle.bam \\\n-wd ./mclumi/data/ \\\n-vb True\n</code></pre></p>"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#22_attributes_in_the_command","title":"2.2 Attributes in the command","text":"<p>Illustration</p> Attribute Description <code>-m</code> UMI deduplication method <code>-ed</code> edit distance <code>-pfpn</code> YAML parameter file. Please see the <code>YAML</code> tab for parameter details <code>-bfpn</code> input file in the BAM format <code>-wd</code> working directory <code>-vb</code> whether to print intermediate results"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#23_yaml_file_configuration","title":"2.3 YAML file configuration","text":"<pre><code>work_dir: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/\n\n# bam_fpn: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/example_bundle.bam\n\numi:\n  ed_thres: 1\n\ndedup:\n  # mcl_val\n  mcl_fold_thres: 1.\n  inflat_val: 1.1\n  exp_val: 2\n  iter_num: 100\n\n  # mcl_ed\n  mcl_fold_thres: 1.6\n  inflat_val: 1.1\n  exp_val: 2\n  iter_num: 100\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#24_attributes_in_the_yaml_file","title":"2.4 Attributes in the YAML file","text":"<p>Illustration</p> Attribute Description <code>work_dir</code> working directory <code>ed_thres</code> edit distance <code>inflat_val</code> inflation parameter of the Markov Clustering algorithm <code>exp_val</code> expansion parameter of the Markov Clustering algorithm <code>iter_num</code> number of interations for the Markov Clustering algorithm to converge <code>mcl_fold_thres</code> a fold change threshold for MCL at a range of (1, <code>l</code>) where <code>l</code> is the length of a UMI. This parameter is placed when the <code>mcl_ed</code> or <code>mcl_val</code> function is used."},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#output","title":"Output","text":""},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#1_console","title":"1. Console","text":"<pre><code>                   ____  ____  _______\n   ____ ___  _____/ / / / /  |/  /  _/\n  / __ `__ \\/ ___/ / / / / /|_/ // /  \n / / / / / / /__/ / /_/ / /  / // /   \n/_/ /_/ /_/\\___/_/\\____/_/  /_/___/   \n\n\n26/07/2024 18:49:19 logger: ===&gt;You are using method MCL to deduplicate UMIs observed at a genomic loci.\n26/07/2024 18:49:19 logger: ===&gt;reading the bam file... /mnt/d/Document/Programming/Python/mclumi/mclumi/data/example_bundle.bam\n26/07/2024 18:49:19 logger: ===&gt;reading BAM time: 0.00s\n26/07/2024 18:49:19 logger: =========&gt;start converting bam to df...\n26/07/2024 18:49:27 logger: =========&gt;time to df: 7.235s\n26/07/2024 18:49:27 logger: ======&gt;# of raw reads: 1175027\n26/07/2024 18:49:27 logger: ======&gt;# of reads with qualified chrs: 1175027\n26/07/2024 18:49:27 logger: ======&gt;# of unique umis: 1949\n26/07/2024 18:49:27 logger: ======&gt;# of redundant umis: 1175027\n26/07/2024 18:49:27 logger: ======&gt;edit distance thres: 1\n26/07/2024 18:49:27 logger: ======&gt;# of columns in the bam df: 14\n26/07/2024 18:49:27 logger: ======&gt;Columns in the bam df: ['id', 'query_name', 'flag', 'reference_id', 'genome_pos', 'mapping_quality', 'cigar', 'query_sequence', 'next_reference_id', 'next_reference_start', 'query_qualities', 'read', 'umi', 'source']\n26/07/2024 18:49:27 logger: ======&gt;# of raw reads:\n              id                     query_name  ...        umi  source\n0              0  SRR2057595.11715337_ACCGGTTTA  ...  ACCGGTTTA       1\n1              1  SRR2057595.11715337_ACCGGTTTA  ...  ACCGGTTTA       1\n2              2  SRR2057595.11715337_ACCGGTTTA  ...  ACCGGTTTA       1\n3              3  SRR2057595.11715337_ACCGGTTTA  ...  ACCGGTTTA       1\n4              4  SRR2057595.11715337_ACCGGTTTA  ...  ACCGGTTTA       1\n...          ...                            ...  ...        ...     ...\n1175022  1175022   SRR2057595.8512200_ACCGGTTGG  ...  ACCGGTTGG       1\n1175023  1175023   SRR2057595.8512200_ACCGGTTGG  ...  ACCGGTTGG       1\n1175024  1175024   SRR2057595.8512200_ACCGGTTGG  ...  ACCGGTTGG       1\n1175025  1175025   SRR2057595.8512200_ACCGGTTGG  ...  ACCGGTTGG       1\n1175026  1175026   SRR2057595.8512200_ACCGGTTGG  ...  ACCGGTTGG       1\n\n[1175027 rows x 14 columns]\n26/07/2024 18:49:27 logger: ===&gt;start building umi graphs...\n26/07/2024 18:49:31 logger: ===&gt;time for building umi graphs: 3.99s\n1    {0: [0, 77, 97, 153, 239, 433, 518, 562, 930, ...\nName: mcl, dtype: object\n===&gt;Analysis has been complete and results have been saved!\n                                            vignette  ...                                        mcl_bam_ids\n1  {'graph_adj': {0: [77, 81, 97, 153, 205, 228, ...  ...  [1980, 45509, 93558, 17999, 50319, 3664, 44368...\n\n[1 rows x 12 columns]\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/1.-Single-locus/#2_understanding_results","title":"2. Understanding results","text":"<p>After running, the generated files are shown in the following screenshot.</p> Fig 1. Generated files with MCL <p>In the output directory, there are two files:</p> <p>Annotation</p> <ul> <li><code>{method}_dedup_sum.txt</code> - deduplicated UMI counts across all reads in the newly generated bam file.</li> <li><code>{method}_dedup.bam</code> - in which the deduplicated reads will be stored.</li> </ul> <p>Statistics provided in file <code>mcl_dedup_sum.txt</code> are tabulated as follow:</p> index {method}_umi_len ave_eds uniq_umi_len dedup_uniq_diff_pos dedup_read_diff_pos 1 44 5.0 1949 1905 1116981 <p>Annotation</p> <ul> <li><code>the 1st column</code> - the given locus.</li> <li><code>the 2nd column</code> - deduplicated UMI counts (corresponding to the number of DNA molecules/transcripts) at the given locus.</li> <li><code>the 3rd column</code> - average edit distances between UMIs at the given locus.</li> <li><code>the 4th column</code> - unique UMI counts at the given locus.</li> <li><code>the 5th column</code> - difference in dedup UMI counts and original unique UMI counts.</li> <li><code>the 6th column</code> - difference in the number of dedup reads and original reads.</li> </ul>"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/","title":"2. Multiple loci","text":"<p><code>mclumi.multipos</code> is a module used for deduplicating UMIs observed at multiple genomic positions/loci or multiple genes.</p>"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#usage","title":"Usage","text":"<p>The <code>mclumi.multipos</code> module can be used in Python and Shell.</p>"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#1_python","title":"1. Python","text":""},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#11_command","title":"1.1 Command","text":"MCLMCL-valMCL-edUniqueClusterAdjacencyDirectional <pre><code>import mclumi as mu\n\ndf_mcl = mu.multipos.mcl(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    pos_tag='PO',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_mcl_val = mu.multipos.mcl_val(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    pos_tag='PO',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    mcl_fold_thres=1.5,\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl_val)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_mcl_ed = mu.multipos.mcl_ed(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    pos_tag='PO',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    mcl_fold_thres=1.5,\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl_ed)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_unique = mu.multipos.unique(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    pos_tag='PO',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\nprint(df_unique)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_cluster = mu.multipos.cluster(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    pos_tag='PO',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\nprint(df_cluster)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_adjacency = mu.multipos.adjacency(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    pos_tag='PO',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\nprint(df_adjacency)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_directional = mu.multipos.directional(\n    bam_fpn=to('data/example_bundle.bam'),\n    ed_thres=1,\n    pos_tag='PO',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\nprint(df_directional)\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#12_attributes_in_the_yaml_file","title":"1.2 Attributes in the YAML file","text":"<p>Illustration</p> Attribute Description <code>ed_thres</code> edit distance <code>pos_tag</code> the tag to denote from which genomic position/locus a read is observed. For example, <code>mclumi.prep.umi_tools</code> function outputs reads whose positions are tagged with <code>PO</code> <code>bam_fpn</code> input file in the BAM format <code>heterogeneity</code> mode to indicate if studying trajectories of UMI origins and copies/derivatives across a series of PCR amplication cycles. If <code>heterogeneity</code> is set to <code>True</code>, users will gain more statistics and files in the final output directory <code>inflat_val</code> inflation parameter of the Markov Clustering algorithm <code>exp_val</code> expansion parameter of the Markov Clustering algorithm <code>iter_num</code> number of interations for the Markov Clustering algorithm to converge <code>mcl_fold_thres</code> a fold change threshold for MCL at a range of (1, <code>l</code>) where <code>l</code> is the length of a UMI. This parameter is placed when the <code>mcl_ed</code> or <code>mcl_val</code> function is used. <code>verbose</code> whether to print intermediate results"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#2_shell","title":"2. Shell","text":""},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#21_command","title":"2.1 Command","text":"<p>The shell command is simplified, but more parameters should be specified in a YAML file, <code>params.yml</code> in order to reduce complexity but optimise future extension. <pre><code>mclumi loci \\\n-m mcl \\\n-ed 1  \\\n-pfpn ./mclumi/data/params.yml \\\n-bfpn ./mclumi/data/example_bundle.bam \\\n-wd ./mclumi/data/ \\\n-vb True\n</code></pre></p>"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#22_attributes_in_the_command","title":"2.2 Attributes in the command","text":"<p>Illustration</p> Attribute Description <code>-m</code> UMI deduplication method <code>-ed</code> edit distance <code>-pfpn</code> YAML parameter file. Please see the <code>YAML</code> tab for parameter details <code>-bfpn</code> input file in the BAM format <code>-wd</code> working directory <code>-vb</code> whether to print intermediate results"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#23_yaml_file_configuration","title":"2.3 YAML file configuration","text":"<pre><code>work_dir: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/\n\n# bam_fpn: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/example_bundle.bam\n\ntag:\n  # loci\n  pos_tag: PO\n\numi:\n  ed_thres: 1\n\ndedup:\n  # mcl_val\n  mcl_fold_thres: 1.\n  inflat_val: 1.1\n  exp_val: 2\n  iter_num: 100\n\n  # mcl_ed\n  mcl_fold_thres: 1.6\n  inflat_val: 1.1\n  exp_val: 2\n  iter_num: 100\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#24_attributes_in_the_yaml_file","title":"2.4 Attributes in the YAML file","text":"<p>Illustration</p> Attribute Description <code>work_dir</code> working directory <code>ed_thres</code> edit distance <code>pos_tag</code> the tag to denote from which genomic position/locus a read is observed. For example, <code>mclumi.prep.umi_tools</code> function outputs reads whose positions are tagged with <code>PO</code> <code>inflat_val</code> inflation parameter of the Markov Clustering algorithm <code>exp_val</code> expansion parameter of the Markov Clustering algorithm <code>iter_num</code> number of interations for the Markov Clustering algorithm to converge <code>mcl_fold_thres</code> a fold change threshold for MCL at a range of (1, <code>l</code>) where <code>l</code> is the length of a UMI. This parameter is placed when the <code>mcl_ed</code> or <code>mcl_val</code> function is used."},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#output","title":"Output","text":""},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#1_console","title":"1. Console","text":"<pre><code>                   ____  ____  _______\n   ____ ___  _____/ / / / /  |/  /  _/\n  / __ `__ \\/ ___/ / / / / /|_/ // /  \n / / / / / / /__/ / /_/ / /  / // /   \n/_/ /_/ /_/\\___/_/\\____/_/  /_/___/   \n\n\n26/07/2024 16:47:09 logger: ===&gt;You are using method MCL to deduplicate UMIs observed at multiple genomic loci.\n26/07/2024 16:47:09 logger: ===&gt;reading the bam file... /mnt/d/Document/Programming/Python/mclumi/mclumi/data/example_bundle.bam\n26/07/2024 16:47:09 logger: ===&gt;reading BAM time: 0.00s\n26/07/2024 16:47:09 logger: =========&gt;start converting bam to df...\n26/07/2024 16:47:17 logger: =========&gt;time to df: 7.347s\n26/07/2024 16:47:17 logger: ======&gt;# of raw reads: 1175027\n26/07/2024 16:47:17 logger: ======&gt;# of reads with qualified chrs: 1175027\n26/07/2024 16:47:17 logger: ======&gt;# of unique umis: 1949\n26/07/2024 16:47:17 logger: ======&gt;# of redundant umis: 1175027\n26/07/2024 16:47:17 logger: ======&gt;edit distance thres: 1\n26/07/2024 16:47:17 logger: ======&gt;# of columns in the bam df: 14\n26/07/2024 16:47:17 logger: ======&gt;Columns in the bam df: ['id', 'query_name', 'flag', 'reference_id', 'genome_pos', 'mapping_quality', 'cigar', 'query_sequence', 'next_reference_id', 'next_reference_start', 'query_qualities', 'read', 'PO', 'umi']\n26/07/2024 16:47:17 logger: ======&gt;# of raw reads:\n              id                     query_name  ...     PO        umi\n0              0  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA\n1              1  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA\n2              2  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA\n3              3  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA\n4              4  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA\n...          ...                            ...  ...    ...        ...\n1175022  1175022   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG\n1175023  1175023   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG\n1175024  1175024   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG\n1175025  1175025   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG\n1175026  1175026   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG\n\n[1175027 rows x 14 columns]\n26/07/2024 16:47:17 logger: ===&gt;start building umi graphs...\n26/07/2024 16:47:36 logger: ===&gt;time for building umi graphs: 18.15s\n0                           {0: [0]}\n1                           {0: [0]}\n2                           {0: [0]}\n3                        {0: [0, 1]}\n4                           {0: [0]}\n                    ...             \n12042                       {0: [0]}\n12043                       {0: [0]}\n12044    {0: [0], 1: [1], 2: [2, 3]}\n12045            {0: [0, 1], 1: [2]}\n12046               {0: [0], 1: [1]}\nName: mcl, Length: 12047, dtype: object\n===&gt;Analysis has been complete and results have been saved!\n                                                vignette  ...                  mcl_bam_ids\n0      {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                          [0]\n1      {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                         [74]\n2      {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                         [75]\n3      {'graph_adj': {0: [1], 1: [0]}, 'int_to_umi_di...  ...                         [76]\n4      {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                        [351]\n...                                                  ...  ...                          ...\n12042  {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                    [1174155]\n12043  {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                    [1174641]\n12044  {'graph_adj': {0: [], 1: [], 2: [3], 3: [2]}, ...  ...  [1174642, 1174712, 1174760]\n12045  {'graph_adj': {0: [1], 1: [0], 2: []}, 'int_to...  ...           [1174888, 1175019]\n12046  {'graph_adj': {0: [], 1: []}, 'int_to_umi_dict...  ...           [1175021, 1175022]\n\n[12047 rows x 12 columns]\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/2.-Multiple-loci/#2_understanding_results","title":"2. Understanding results","text":"<p>After running, the generated files are shown in the following screenshot.</p> Fig 1. Generated files with MCL <p>In the output directory, there are three files:</p> <p>Annotation</p> <ul> <li><code>{method}_ave_ed_pos_bin.txt</code> - in which UMI count summary results will be stored, indicating observed UMIs under multiple genomic positions/loci.</li> <li><code>{method}_dedup_sum.txt</code> - deduplicated UMI counts across all reads in the newly generated bam file.</li> <li><code>{method}_dedup.bam</code> - in which the deduplicated reads will be stored.</li> </ul> <p>Statistics provided in file <code>mcl_ave_ed_pos_bin.txt</code> are tabulated as follow:</p> ave_eds count -1.0 10470 2.0 162 3.0 206 ... ... <p>Annotation</p> <ul> <li><code>the 1st column</code> - average edit distance between UMIs at genomic positions.</li> <li><code>the 2nd column</code> - number of reads tagged with UMIs observed in that edit distance.</li> <li><code>*</code> <code>-1.0</code> in column <code>edit distance</code> represents that only one unique umi seen at a single genomic position; in total there are 10470 genomic positions seen with one unique umi.</li> </ul> <p>Statistics provided in file <code>mcl_dedup_sum.txt</code> are tabulated as follow:</p> index {method}_umi_len ave_eds uniq_umi_len dedup_uniq_diff_pos dedup_read_diff_pos 0 4 4.0 4 0 0 1 2 5.0 2 0 0 2 7 4.0 9 2 2 ... ... ... ... ... ... <p>Annotation</p> <ul> <li><code>the 1st column</code> - genomic positions of interest.</li> <li><code>the 2nd column</code> - deduplicated UMI counts (corresponding to the number of DNA molecules/transcripts) at genomic positions.</li> <li><code>the 3rd column</code> - average edit distances between UMIs at given genomic positions.</li> <li><code>the 4th column</code> - unique UMI counts at given genomic positions.</li> <li><code>the 5th column</code> - difference in dedup UMI counts and original unique UMI counts.</li> <li><code>the 6th column</code> - difference in the number of dedup reads and original reads.</li> </ul>"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/","title":"3. Gene with bulk RNA seq","text":"<p><code>mclumi.gene</code> is a module used for deduplicating UMIs aligned to genes at the bulk RNA-seq levels.</p>"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#usage","title":"Usage","text":"<p>The <code>mclumi.gene</code> module can be used in Python and Shell.</p>"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#1_python","title":"1. Python","text":""},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#11_command","title":"1.1 Command","text":"MCLMCL-valMCL-edUniqueClusterAdjacencyDirectional <pre><code>import mclumi as mu\n\ndf_mcl = mu.gene.mcl(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_mcl_val = mu.gene.mcl_val(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    mcl_fold_thres=1.5,\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl_val)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_mcl_ed = mu.gene.mcl_ed(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    mcl_fold_thres=1.5,\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl_ed)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_unique = mu.gene.unique(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_unique)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_cluster = mu.gene.cluster(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_cluster)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_adjacency = mu.gene.adjacency(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_adjacency)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_directional = mu.gene.directional(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_directional)\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#12_attributes_in_the_yaml_file","title":"1.2 Attributes in the YAML file","text":"<p>Illustration</p> Attribute Description <code>ed_thres</code> edit distance <code>gene_assigned_tag</code> to enable deduplication on the gene tag (XT recommended). Any other tag if you know what tags the reads in your provided BAM file. <code>gene_is_assigned_tag</code> to check if reads are assigned the gene tag (XS recommended) <code>bam_fpn</code> input file in the BAM format <code>heterogeneity</code> mode to indicate if studying trajectories of UMI origins and copies/derivatives across a series of PCR amplication cycles. If <code>heterogeneity</code> is set to <code>True</code>, users will gain more statistics and files in the final output directory <code>inflat_val</code> inflation parameter of the Markov Clustering algorithm <code>exp_val</code> expansion parameter of the Markov Clustering algorithm <code>iter_num</code> number of interations for the Markov Clustering algorithm to converge <code>mcl_fold_thres</code> a fold change threshold for MCL at a range of (1, <code>l</code>) where <code>l</code> is the length of a UMI. This parameter is placed when the <code>mcl_ed</code> or <code>mcl_val</code> function is used. <code>verbose</code> whether to print intermediate results"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#2_shell","title":"2. Shell","text":""},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#21_command","title":"2.1 Command","text":"<p>The shell command is simplified, but more parameters should be specified in a YAML file, <code>params.yml</code> in order to reduce complexity but optimise future extension. <pre><code>mclumi bulk \\\n-m mcl \\\n-ed 1  \\\n-pfpn ./mclumi/data/params.yml \\\n-bfpn ./mclumi/data/RM82CLK1_S3_featurecounts_gene_sorted.bam \\\n-wd ./mclumi/data/ \\\n-vb True\n</code></pre></p>"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#22_attributes_in_the_command","title":"2.2 Attributes in the command","text":"<p>Illustration</p> Attribute Description <code>-m</code> UMI deduplication method <code>-ed</code> edit distance <code>-pfpn</code> YAML parameter file. Please see the <code>YAML</code> tab for parameter details <code>-bfpn</code> input file in the BAM format <code>-wd</code> working directory <code>-vb</code> whether to print intermediate results"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#23_yaml_file_configuration","title":"2.3 YAML file configuration","text":"<pre><code>work_dir: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/\n\n# bam_fpn: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/example_bundle.bam\n\ntag:\n  # bulk\n  gene_assigned_tag: XT\n  gene_is_assigned_tag: XS\n\numi:\n  ed_thres: 1\n\ndedup:\n  # mcl_val\n  mcl_fold_thres: 1.\n  inflat_val: 1.1\n  exp_val: 2\n  iter_num: 100\n\n  # mcl_ed\n  mcl_fold_thres: 1.6\n  inflat_val: 1.1\n  exp_val: 2\n  iter_num: 100\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#24_attributes_in_the_yaml_file","title":"2.4 Attributes in the YAML file","text":"<p>Illustration</p> Attribute Description <code>work_dir</code> working directory <code>ed_thres</code> edit distance <code>gene_assigned_tag</code> to enable deduplication on the gene tag (XT recommended). Any other tag if you know what tags the reads in your provided BAM file. <code>gene_is_assigned_tag</code> to check if reads are assigned the gene tag (XS recommended) <code>inflat_val</code> inflation parameter of the Markov Clustering algorithm <code>exp_val</code> expansion parameter of the Markov Clustering algorithm <code>iter_num</code> number of interations for the Markov Clustering algorithm to converge <code>mcl_fold_thres</code> a fold change threshold for MCL at a range of (1, <code>l</code>) where <code>l</code> is the length of a UMI. This parameter is placed when the <code>mcl_ed</code> or <code>mcl_val</code> function is used."},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#output","title":"Output","text":""},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#1_console","title":"1. Console","text":"<pre><code>                   ____  ____  _______\n   ____ ___  _____/ / / / /  |/  /  _/\n  / __ `__ \\/ ___/ / / / / /|_/ // /  \n / / / / / / /__/ / /_/ / /  / // /   \n/_/ /_/ /_/\\___/_/\\____/_/  /_/___/   \n\n\n26/07/2024 17:52:36 logger: ===&gt;You are using method MCL to deduplicate UMIs observed at bulk RNA-seq levels\n26/07/2024 17:52:36 logger: ===&gt;reading the bam file... /mnt/d/Document/Programming/Python/mclumi/mclumi/data/hgmm_100_STAR_FC_sorted.bam\n26/07/2024 17:52:36 logger: ===&gt;reading BAM time: 0.00s\n26/07/2024 17:52:36 logger: =========&gt;start converting bam to df...\n26/07/2024 17:53:14 logger: =========&gt;time to df: 38.528s\n26/07/2024 17:53:15 logger: ======&gt;# of raw reads: 3553230\n26/07/2024 17:53:16 logger: ======&gt;# of reads with qualified chrs: 3553230\n26/07/2024 17:53:17 logger: ======&gt;# of unique umis: 100\n26/07/2024 17:53:17 logger: ======&gt;# of redundant umis: 588963\n26/07/2024 17:53:17 logger: ======&gt;edit distance thres: 1\n26/07/2024 17:53:18 logger: ======&gt;# of columns in the bam df: 15\n26/07/2024 17:53:18 logger: ======&gt;Columns in the bam df: ['id', 'query_name', 'flag', 'reference_id', 'genome_pos', 'mapping_quality', 'cigar', 'query_sequence', 'next_reference_id', 'next_reference_start', 'query_qualities', 'read', 'XT', 'XS', 'umi']\n26/07/2024 17:53:18 logger: ======&gt;# of raw reads:\n              id  ...               umi\n0              0  ...  GGTGCGTAGGCTACGA\n1              1  ...  TGACTAGGTGTGGTTT\n2              2  ...  CAGATCATCGTCGTTC\n3              3  ...  TTTGCGCCAAGTCTGT\n4              4  ...  GCAGCCATCATCATTC\n...          ...  ...               ...\n3552647  3552647  ...  AGAGCTTCACGACGAA\n3552648  3552648  ...  GTAACTGAGTGAAGTT\n3552649  3552649  ...  ACACCGGGTACGACCC\n3552650  3552650  ...  ATCACGAGTAATTGGA\n3552651  3552651  ...  ACTATCTCAAGGTGTG\n\n[588963 rows x 15 columns]\n26/07/2024 17:53:18 logger: ===&gt;start building umi graphs...\n26/07/2024 17:53:38 logger: ===&gt;time for building umi graphs: 20.07s\nexon-NM_000059.4-10    {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5...\nexon-NM_000059.4-11    {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5...\nexon-NM_000059.4-19                                             {0: [0]}\nexon-NM_000059.4-22                             {0: [0], 1: [1], 2: [2]}\nexon-NM_000059.4-27     {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5]}\n                                             ...                        \nid-YWHAEP5              {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5]}\nid-YWHAQP2             {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5...\nid-YWHAQP6             {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5...\nid-ZBTB12BP                                                     {0: [0]}\nid-ZNF887P-3                                            {0: [0], 1: [1]}\nName: mcl, Length: 10961, dtype: object\n===&gt;Analysis has been complete and results have been saved!\n                                                              vignette  ...                                        mcl_bam_ids\nexon-NM_000059.4-10  {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...  [2089439, 2089440, 2089441, 2089442, 2089443, ...\nexon-NM_000059.4-11  {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...  [2089459, 2089460, 2089462, 2089464, 2089465, ...\nexon-NM_000059.4-19  {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                                          [2089514]\nexon-NM_000059.4-22  {'graph_adj': {0: [], 1: [], 2: []}, 'int_to_u...  ...                        [2089521, 2089522, 2089523]\nexon-NM_000059.4-27  {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...  [2089541, 2089542, 2089543, 2089545, 2089546, ...\n...                                                                ...  ...                                                ...\nid-YWHAEP5           {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...   [470009, 470010, 470011, 470012, 470013, 470014]\nid-YWHAQP2           {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...  [3252877, 3252878, 3252879, 3252880, 3252881, ...\nid-YWHAQP6           {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...  [725797, 725798, 725799, 725801, 725803, 72580...\nid-ZBTB12BP          {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                                           [785548]\nid-ZNF887P-3         {'graph_adj': {0: [], 1: []}, 'int_to_umi_dict...  ...                                 [2856335, 2856336]\n\n[10961 rows x 12 columns]\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/3.-Gene-with-bulk-RNA-seq/#2_understanding_results","title":"2. Understanding results","text":"<p>After running, the generated files are shown in the following screenshot.</p> Fig 1. Generated files with MCL <p>In the output directory, there are three files:</p> <p>Annotation</p> <ul> <li><code>{method}_ave_ed_pos_bin.txt</code> - in which UMI count summary results will be stored, indicating observed UMIs assigned to multiple genes.</li> <li><code>{method}_dedup_sum.txt</code> - deduplicated UMI counts across all reads in the newly generated bam file.</li> <li><code>{method}_dedup.bam</code> - in which the deduplicated reads will be stored.</li> </ul> <p>Statistics provided in file <code>mcl_ave_ed_pos_bin.txt</code> are tabulated as follow:</p> ave_eds count -1.0 4339 6.0 1 7.0 26 ... ... <p>Annotation</p> <ul> <li><code>the 1st column</code> - average edit distance between UMIs.</li> <li><code>the 2nd column</code> - number of UMI-tagged reads observed in that edit distance.</li> <li><code>*</code> <code>-1.0</code> in column <code>edit distance</code> represents that only one unique umi seen for all types of genes; in total there are 4339 reads seen with one unique umi.</li> </ul> <p>Statistics provided in file <code>mcl_dedup_sum.txt</code> are tabulated as follow:</p> index {method}_umi_len ave_eds uniq_umi_len dedup_uniq_diff_pos dedup_read_diff_pos exon-NM_000059.4-10 11 13.0 11 0 0 exon-NM_000059.4-11 9 13.0 9 0 0 exon-NM_000059.4-22 3 13.0 3 0 0 ... ... ... ... ... ... <p>Annotation</p> <ul> <li><code>the 1st column</code> - gene types/marker.</li> <li><code>the 2nd column</code> - deduplicated UMI counts (corresponding to the number of DNA molecules/transcripts) for a given gene type.</li> <li><code>the 3rd column</code> - average edit distances between UMIs for given gene types.</li> <li><code>the 4th column</code> - unique UMI counts for given gene types.</li> <li><code>the 5th column</code> - difference in dedup UMI counts and original unique UMI counts.</li> <li><code>the 6th column</code> - difference in the number of dedup reads and original reads.</li> </ul>"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/","title":"4. Gene with scRNA seq","text":"<p><code>mclumi.sc</code> is a module used for deduplicating UMIs aligned to genes at the single-cell RNA-seq (scRNA-seq) levels.</p>"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#usage","title":"Usage","text":"<p>The <code>mclumi.sc</code> module can be used in Python and Shell.</p>"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#1_python","title":"1. Python","text":""},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#11_command","title":"1.1 Command","text":"MCLMCL-valMCL-edUniqueClusterAdjacencyDirectional <pre><code>import mclumi as mu\n\ndf_mcl = mu.sc.mcl(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_mcl_val = mu.sc.mcl_val(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    mcl_fold_thres=1.5,\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl_val)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_mcl_ed = mu.sc.mcl_ed(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n\n    mcl_fold_thres=1.5,\n    inflat_val=1.6,\n    exp_val=2,\n    iter_num=100,\n)\n\nprint(df_mcl_ed)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_unique = mu.sc.unique(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_unique)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_cluster = mu.sc.cluster(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_cluster)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_adjacency = mu.sc.adjacency(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_adjacency)\n</code></pre> <pre><code>import mclumi as mu\n\ndf_directional = mu.sc.directional(\n    bam_fpn=to('data/hgmm_100_STAR_FC_sorted.bam'),\n    ed_thres=1,\n    gene_assigned_tag='XT',\n    gene_is_assigned_tag='XS',\n    work_dir=to('data/'),\n    verbose=False,  # False True\n\n    heterogeneity=False,  # False True\n)\n\nprint(df_directional)\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#12_attributes_in_the_yaml_file","title":"1.2 Attributes in the YAML file","text":"<p>Illustration</p> Attribute Description <code>ed_thres</code> edit distance <code>gene_assigned_tag</code> to enable deduplication on the gene tag (XT recommended). Any other tag if you know what tags the reads in your provided BAM file. <code>gene_is_assigned_tag</code> to check if reads are assigned the gene tag (XS recommended) <code>bam_fpn</code> input file in the BAM format <code>heterogeneity</code> mode to indicate if studying trajectories of UMI origins and copies/derivatives across a series of PCR amplication cycles. If <code>heterogeneity</code> is set to <code>True</code>, users will gain more statistics and files in the final output directory <code>inflat_val</code> inflation parameter of the Markov Clustering algorithm <code>exp_val</code> expansion parameter of the Markov Clustering algorithm <code>iter_num</code> number of interations for the Markov Clustering algorithm to converge <code>mcl_fold_thres</code> a fold change threshold for MCL at a range of (1, <code>l</code>) where <code>l</code> is the length of a UMI. This parameter is placed when the <code>mcl_ed</code> or <code>mcl_val</code> function is used. <code>verbose</code> whether to print intermediate results"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#2_shell","title":"2. Shell","text":""},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#21_command","title":"2.1 Command","text":"<p>The shell command is simplified, but more parameters should be specified in a YAML file, <code>params.yml</code> in order to reduce complexity but optimise future extension. <pre><code>mclumi sc \\\n-m mcl \\\n-ed 1  \\\n-pfpn ./mclumi/data/params.yml \\\n-bfpn ./mclumi/data/hgmm_100_STAR_FC_sorted.bam \\\n-wd ./mclumi/data/ \\\n-vb True\n</code></pre></p>"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#22_attributes_in_the_command","title":"2.2 Attributes in the command","text":"<p>Illustration</p> Attribute Description <code>-m</code> UMI deduplication method <code>-ed</code> edit distance <code>-pfpn</code> YAML parameter file. Please see the <code>YAML</code> tab for parameter details <code>-bfpn</code> input file in the BAM format <code>-wd</code> working directory <code>-vb</code> whether to print intermediate results"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#23_yaml_file_configuration","title":"2.3 YAML file configuration","text":"<pre><code>work_dir: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/\n\n# bam_fpn: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/example_bundle.bam\n\ntag:\n  # bulk\n  gene_assigned_tag: XT\n  gene_is_assigned_tag: XS\n\numi:\n  ed_thres: 1\n\ndedup:\n  # mcl_val\n  mcl_fold_thres: 1.\n  inflat_val: 1.1\n  exp_val: 2\n  iter_num: 100\n\n  # mcl_ed\n  mcl_fold_thres: 1.6\n  inflat_val: 1.1\n  exp_val: 2\n  iter_num: 100\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#24_attributes_in_the_yaml_file","title":"2.4 Attributes in the YAML file","text":"<p>Illustration</p> Attribute Description <code>work_dir</code> working directory <code>ed_thres</code> edit distance <code>gene_assigned_tag</code> to enable deduplication on the gene tag (XT recommended). Any other tag if you know what tags the reads in your provided BAM file. <code>gene_is_assigned_tag</code> to check if reads are assigned the gene tag (XS recommended) <code>inflat_val</code> inflation parameter of the Markov Clustering algorithm <code>exp_val</code> expansion parameter of the Markov Clustering algorithm <code>iter_num</code> number of interations for the Markov Clustering algorithm to converge <code>mcl_fold_thres</code> a fold change threshold for MCL at a range of (1, <code>l</code>) where <code>l</code> is the length of a UMI. This parameter is placed when the <code>mcl_ed</code> or <code>mcl_val</code> function is used."},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#output","title":"Output","text":""},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#1_console","title":"1. Console","text":"<pre><code>                   ____  ____  _______\n   ____ ___  _____/ / / / /  |/  /  _/\n  / __ `__ \\/ ___/ / / / / /|_/ // /  \n / / / / / / /__/ / /_/ / /  / // /   \n/_/ /_/ /_/\\___/_/\\____/_/  /_/___/   \n\n\n26/07/2024 18:09:33 logger: ===&gt;You are using method MCL to deduplicate UMIs observed at scRNA-seq levels.\n26/07/2024 18:09:33 logger: ===&gt;reading the bam file... /mnt/d/Document/Programming/Python/mclumi/mclumi/data/hgmm_100_STAR_FC_sorted.bam\n26/07/2024 18:09:33 logger: ===&gt;reading BAM time: 0.00s\n26/07/2024 18:09:33 logger: =========&gt;start converting bam to df...\n26/07/2024 18:10:10 logger: =========&gt;time to df: 37.209s\n26/07/2024 18:10:10 logger: ======&gt;# of raw reads: 3553230\n26/07/2024 18:10:11 logger: ======&gt;# of reads with qualified chrs: 3553230\n26/07/2024 18:10:13 logger: ======&gt;# of unique barcodes: 100\n26/07/2024 18:10:13 logger: ======&gt;# of unique umis: 367552\n26/07/2024 18:10:13 logger: ======&gt;# of redundant umis: 588963\n26/07/2024 18:10:13 logger: ======&gt;edit distance thres: 1\n26/07/2024 18:10:14 logger: ======&gt;# of gene-by-cell positions in the bam: 102842\n26/07/2024 18:10:14 logger: ======&gt;# of columns in the bam df: 16\n26/07/2024 18:10:14 logger: ======&gt;Columns in the bam df: ['id', 'query_name', 'flag', 'reference_id', 'genome_pos', 'mapping_quality', 'cigar', 'query_sequence', 'next_reference_id', 'next_reference_start', 'query_qualities', 'read', 'XT', 'XS', 'bc', 'umi']\n26/07/2024 18:10:14 logger: ======&gt;# of raw reads:\n              id  ...         umi\n0              0  ...  CCGGAGAGGG\n1              1  ...  CGCCCCCGGG\n2              2  ...  CCCGAGAATT\n3              3  ...  AAATAGCTAG\n4              4  ...  TCTGCTTTAG\n...          ...  ...         ...\n3552647  3552647  ...  AATCCTCTGG\n3552648  3552648  ...  GGCCGGTGGG\n3552649  3552649  ...  CAAACGATAA\n3552650  3552650  ...  CAACACAAGT\n3552651  3552651  ...  TGATTGAAGC\n\n[588963 rows x 16 columns]\n26/07/2024 18:10:14 logger: ===&gt;start building umi graphs...\n26/07/2024 18:13:13 logger: ===&gt;time for building umi graphs: 178.78s\n(AAAGATGAGAAACGAG, exon-NM_000099.4-3)     {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5]}\n(AAAGATGAGAAACGAG, exon-NM_000100.4-3)    {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5...\n(AAAGATGAGAAACGAG, exon-NM_000101.4-6)                             {0: [0], 1: [1], 2: [2]}\n(AAAGATGAGAAACGAG, exon-NM_000146.4-3)                                     {0: [0], 1: [1]}\n(AAAGATGAGAAACGAG, exon-NM_000146.4-4)    {0: [0], 1: [1], 2: [2], 3: [3], 4: [4], 5: [5...\n                                                                ...                        \n(TTTGCGCCAAGTCTGT, id-TCEA1P2)                                                     {0: [0]}\n(TTTGCGCCAAGTCTGT, id-TXNP6)                                               {0: [0], 1: [1]}\n(TTTGCGCCAAGTCTGT, id-VDAC1P2)                                                     {0: [0]}\n(TTTGCGCCAAGTCTGT, id-YBX1P1)                                                      {0: [0]}\n(TTTGCGCCAAGTCTGT, id-YBX1P10)                                                     {0: [0]}\nName: mcl, Length: 102842, dtype: object\n===&gt;Analysis has been complete and results have been saved!\n                                                                                 vignette  ...                                        mcl_bam_ids\n(AAAGATGAGAAACGAG, exon-NM_000099.4-3)  {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...  [3099117, 3099235, 3099257, 3099287, 3099354, ...\n(AAAGATGAGAAACGAG, exon-NM_000100.4-3)  {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...  [3171457, 3171495, 3171504, 3171564, 3171693, ...\n(AAAGATGAGAAACGAG, exon-NM_000101.4-6)  {'graph_adj': {0: [], 1: [], 2: []}, 'int_to_u...  ...                        [2455005, 2455221, 2455320]\n(AAAGATGAGAAACGAG, exon-NM_000146.4-3)  {'graph_adj': {0: [], 1: []}, 'int_to_umi_dict...  ...                                 [3008063, 3008100]\n(AAAGATGAGAAACGAG, exon-NM_000146.4-4)  {'graph_adj': {0: [], 1: [], 2: [], 3: [], 4: ...  ...  [3009218, 3009245, 3009263, 3009571, 3009681, ...\n...                                                                                   ...  ...                                                ...\n(TTTGCGCCAAGTCTGT, id-TCEA1P2)          {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                                           [602919]\n(TTTGCGCCAAGTCTGT, id-TXNP6)            {'graph_adj': {0: [], 1: []}, 'int_to_umi_dict...  ...                                   [799963, 799966]\n(TTTGCGCCAAGTCTGT, id-VDAC1P2)          {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                                          [3284956]\n(TTTGCGCCAAGTCTGT, id-YBX1P1)           {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                                          [2164172]\n(TTTGCGCCAAGTCTGT, id-YBX1P10)          {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                                          [1503503]\n\n[102842 rows x 12 columns]\n</code></pre>"},{"location":"tutorial/I.-UMI-deduplication/4.-Gene-with-scRNA-seq/#2_understanding_results","title":"2. Understanding results","text":"<p>After running, the generated files are shown in the following screenshot.</p> Fig 1. Generated files with MCL <p>In the output directory, there are three files:</p> <p>Annotation</p> <ul> <li><code>{method}_ave_ed_pos_bin.txt</code> - in which UMI count summary results will be stored, indicating observed UMIs assigned to multiple genes.</li> <li><code>{method}_dedup_sum.txt</code> - deduplicated UMI counts across all reads in the newly generated bam file.</li> <li><code>{method}_dedup.bam</code> - in which the deduplicated reads will be stored.</li> </ul> <p>Statistics provided in file <code>mcl_ave_ed_pos_bin.txt</code> are tabulated as follow:</p> ave_eds count -1.0 52980 2.0 7 3.0 36 ... ... <p>Annotation</p> <ul> <li><code>the 1st column</code> - average edit distance between UMIs.</li> <li><code>the 2nd column</code> - number of UMI-tagged reads observed in that edit distance.</li> <li><code>*</code> <code>-1.0</code> in column <code>edit distance</code> represents that only one unique umi seen for all cell-by-gene types; in total there are 52980 reads seen with one unique umi.</li> </ul> <p>Statistics provided in file <code>mcl_dedup_sum.txt</code> are tabulated as follow:</p> index {method}_umi_len ave_eds uniq_umi_len dedup_uniq_diff_pos dedup_read_diff_pos ('AAAGATGAGAAACGAG', 'exon-NM_000099.4-3') 6 8.0 6 0 0 ('AAAGATGAGAAACGAG', 'exon-NM_000100.4-3') 14 8.0 14 0 0 ('AAAGATGAGAAACGAG', 'exon-NM_000101.4-6') 3 8.0 3 0 0 ... ... ... ... ... ... <p>Annotation</p> <ul> <li><code>the 1st column</code> - cell-by-gene types.</li> <li><code>the 2nd column</code> - deduplicated UMI counts (corresponding to the number of DNA molecules/transcripts) for a given cell-by-gene type.</li> <li><code>the 3rd column</code> - average edit distances between UMIs for given cell-by-gene types.</li> <li><code>the 4th column</code> - unique UMI counts for given cell-by-gene types.</li> <li><code>the 5th column</code> - difference in dedup UMI counts and original unique UMI counts.</li> <li><code>the 6th column</code> - difference in the number of dedup reads and original reads.</li> </ul>"},{"location":"tutorial/II.-Appendix/Read-conversion/","title":"Read conversion","text":""},{"location":"tutorial/II.-Appendix/Read-conversion/#umi-tools","title":"UMI-tools","text":"<p>UMI-tools provides a Bundle method to filter reads with high quality. Users can access this method through the <code>mu.prep.run</code> function as follows.</p> <pre><code>import mclumi as mu\n\ndf_mcl = mu.prep.run(\n    method='umi-tools',\n    bam_fpn=to('data/example.bam'),\n    # params=Parameter().bundle_umi_tools,\n    work_dir=to('data/'),\n    verbose=True,\n)\n</code></pre> <p>The following vignette shows how this function filters reads.</p> <pre><code># Parameter().bundle_umi_tools\n\n{\n    'stats': 'deduplicated',\n    'get_umi_method': 'read_id',\n    'umi_sep': '_',\n    'umi_tag': 'RX',\n    'umi_tag_split': None,\n    'umi_tag_delim': None,\n    'cell_tag': None,\n    'cell_tag_split': '-',\n    'cell_tag_delim': None,\n    'filter_umi': None,\n    'umi_whitelist': None,\n    'umi_whitelist_paired': None,\n    'method': 'directional',\n    'threshold': 1,\n    'spliced': False,\n    'soft_clip_threshold': 4,\n    'read_length': False,\n    'per_gene': False,\n    'gene_tag': None,\n    'assigned_tag': None,\n    'skip_regex': '^(__|Unassigned)',\n    'per_contig': False,\n    'gene_transcript_map': None,\n    'per_cell': False,\n    'whole_contig': False,\n    'detection_method': None,\n    'mapping_quality': 0,\n    'output_unmapped': False,\n    'unmapped_reads': 'discard',\n    'chimeric_pairs': 'use',\n    'unpaired_reads': 'use',\n    'ignore_umi': False,\n    'ignore_tlen': False,\n    'chrom': None,\n    'subset': None,\n    'in_sam': False,\n    'paired': False,\n    'out_sam': False,\n    'no_sort_output': False,\n    'stdin': \"&lt;_io.TextIOWrapper name='example.bam' mode='r' encoding='UTF-8'&gt;\",\n    'stdlog': \"&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;\", 'log2stderr': False,\n    'compresslevel': 6,\n    'timeit_file': None,\n    'timeit_name': 'all',\n    'timeit_header': None,\n    'loglevel': 1,\n    'short_help': None,\n    'random_seed': None\n}\n</code></pre> <p>As an example, the <code>example.bam</code> file can be downloaded here. After conversion, the bam file will be named <code>example_bundle.bam</code>, which contains 1,175,027 reads having 20,683 raw unique UMI sequences observed at 12,047 genomic positions.</p> <p>Info</p> <p>The bundle function from UMI-tools is currently the only method in mclUMI for filtering reads. Please stay tuned for more as the development of mclUMI.</p>"},{"location":"tutorial/III.-Data/Download/","title":"Download","text":"<p>Example data used in this tutorial can be obtained as follows.</p> <p>Info</p> <p>1. iCLIP. The M\u00fcller-McNicoll iCLIP dataset<sup>1</sup> can be downloaded here and it contained 1,175,027 reads with 20,683 raw unique UMI sequences and 12,047 genomic positions tagged by running the <code>get_bundles</code> method of UMI-tools or the <code>mclumi.prep.run</code> function in mclUMI.</p> <p>2. Single-cell RNA-seq. A single-cell dataset from 10X Genomics was downloaded from here. It contained 3,553,230 raw reads and left 588,963 reads after STAR (v2.7.9a)<sup>2</sup> mapping against GRCh38 and gene annotations using featureCounts (v2.0.1)<sup>3</sup>. The 100 barcodes were generated using the whitelist function of UMI-tools.</p> <ol> <li> <p>M\u00fcller-McNicoll M, Botti V, de Jesus Domingues AM, Brandl H, Schwich OD, Steiner MC, et al. SR proteins are NXF1 adaptors that link alternative RNA processing to mRNA export. Genes Dev [Internet]. 2016;30:553\u201366. Available from: http://genesdev.cshlp.org/content/30/5/553.abstract\u00a0\u21a9</p> </li> <li> <p>Dobin A, Davis CA, Schlesinger F, Drenkow J, Zaleski C, Jha S, et al. STAR: ultrafast universal RNA-seq aligner. Bioinformatics [Internet]. 2012;29:15\u201321. Available from: https://doi.org/10.1093/bioinformatics/bts635\u00a0\u21a9</p> </li> <li> <p>Liao Y, Smyth GK, Shi W. featureCounts: an efficient general purpose program for assigning sequence reads to genomic features. Bioinformatics [Internet]. 2013;30:923\u201330. Available from: https://doi.org/10.1093/bioinformatics/btt656\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/III.-Data/Format/","title":"Format","text":""},{"location":"tutorial/III.-Data/Format/#input","title":"Input","text":"<p>The input file in BAM format is only acceptable by mclUMI with each read umi attached to the read name. If you hold FASTQ file, you need to map the <code>*.fastq.gz</code> to a reference genome to yield a bam file using a mapping tool, such as Minimap2, HISAT2, or STAR, according to different sequencing reads.</p> <p>Note</p> <p>In single cell sequencing read analysis, barcodes will be attached to the read name yet prior to their UMIs.</p>"},{"location":"tutorial/III.-Data/Format/#output","title":"Output","text":"<p>mclUMI outputs a series of files after UMI deduplication or collapsing. It has two files for recording statistics involved and one bam file as deduplicated reads. Please see details at 4 different UMI deduplication levels.</p>"},{"location":"tutorial/IV.-Method/Euclidean-distance-based-clustering/","title":"Euclidean distance based clustering","text":""},{"location":"tutorial/IV.-Method/Euclidean-distance-based-clustering/#euclidean_distance","title":"Euclidean distance","text":"<p>Apart from the graph-based clustering methods in mclUMI, we implemented several Euclidean distance-based clustering methods, including density-based spatial clustering of applications with noise (DBSCAN)<sup>1</sup>, balanced iterative reducing and clustering using hierarchies (BIRCH)<sup>2</sup>, and Affinity propagation<sup>3</sup>.</p> <p>These methods do not need to build a UMI graph to remove PCR duplicates.</p> <p>UMI sequences are represented by one-hot encodings, which are then flatten to be fed into distance-based clustering algorithms. Our results demonstrate that methods implemented in mclUMI together with DBSCAN, Birch, and Directional show an apparent advantage of UMI collapsing over Unique and Adjacency in all the six sequencing settings.</p> <p>Users can access the Euclidean distance-based clustering methods by passing the following parameters to the YAML file.</p> <p>For DBSCAN <pre><code>dbscan_eps: 1.5\ndbscan_min_spl: 1\n</code></pre></p> <p>For BIRCH <pre><code>birch_thres: 1.8\nbirch_n_clusters: None\n</code></pre></p> <p>For Affinity propagation, there are no parameters to impose on.</p> <ol> <li> <p>Schubert E, Sander J, Ester M, Kriegel HP, Xu X. DBSCAN Revisited, Revisited: Why and How You Should (Still) Use DBSCAN. ACM Trans Database Syst [Internet]. 2017;42. Available from: https://doi.org/10.1145/3068335\u00a0\u21a9</p> </li> <li> <p>Zhang T, Ramakrishnan R, Livny M. BIRCH: A New Data Clustering Algorithm and Its Applications. Data Min Knowl Discov [Internet]. 1997;1:141\u201382. Available from: https://doi.org/10.1023/A:1009783824328\u00a0\u21a9</p> </li> <li> <p>Shang F, Jiao LC, Shi J, Wang F, Gong M. Fast affinity propagation clustering: A multilevel approach. Pattern Recognit [Internet]. 2012;45:474\u201386. Available from: https://www.sciencedirect.com/science/article/pii/S0031320311002007\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/IV.-Method/Markov-clustering/","title":"Markov clustering","text":"<p>We developed mclUMI for automatic detection of UMI clusters without the need for calculating UMI counts by the Markov clustering algorithm. It has two derivatives, MCL-val and MCL-ed, by considering information about UMI counts.</p> Fig 1. Illustration of MCL for UMI deduplicating on a 7-node UMI graph <ul> <li>MCL-val's main thrust bears a very close resemblance to the Directional method. Rather than collapsing UMIs at the node level, MCL-val collapses UMIs at the subcomponent level. MCL-val first picks out UMIs with the highest count from Markov clusters and merges two Markov clusters if the count of one of the most commonly seen UMIs is at least above 2-fold higher than that of the other one.</li> <li>Because the difference between counts of UMIs A and B falls short of the requirement, the two Markov clusters are not merged. Building on subcomponent level, we further designed MCL-ed, which merge two Markov clusters if the two most commonly seen UMIs are k edit distance apart. For the 7-node UMI graph in the following plot, the two Markov clusters are merged because UMIs A and B are within one edit distance.</li> </ul> <p>Tip</p> <p>PCR artefacts or duplicates result from amplification of reads over multiple PCR cycles. Classification of PCR duplicates according to the same UMIs does not work when UMIs are synthesised and/or sequenced incorrectly because of DNA polymerase/sequencing errors. </p> <p>To tackle this problem, graph-based computational strategies are proposed by leveraging edit distances between UMIs to build UMI graphs, which prevail among deduplication methods (see <sup>1</sup> for technical review). Similar to existing methods, mclUMI implements a Markov clustering algorithm for UMI collapsing based on a UMI graph. We began by exemplifying 7 UMIs for 10X V2 chemistry and constructing a UMI graph using an edit distance 1. Upon receiving the adjacency matrix of the UMI graph, mclUMI is asked to search for subcomponents with their respective nodes strongly connected. For instance, a UMI graph composed of 7 nodes is further split into two subcomponents. It shows high connectivity within each of them but low connectivity between them. Nevertheless, Markov clusters are discovered without leveraging the information on UMI counts.</p> Fig 2. Schematic of MCL for UMI deduplication <p>By calculating edit distances between UMIs and setting an editing distance cutoff, a graph is built to graphically present intricate relationships between UMIs. Edges that are used to link UMIs together reflect connectivity between them. If considering UMI counts as node sizes, such a graph can essentially reflect how UMIs with a low count evolve from a UMI with a high count over error-prone PCR amplification and sequencing processes. However, it remains murky as to which UMIs in a graph are most appropriately grouped and considered to originate from the same origin. To cope with this challenge, UMI-tools meticulously designed a set of custom-built, expert-guided rules to construct two methods, Adjacency and Directional. Different from this notion, we conjecture that edges are highly informative to implicit relationships between UMIs and it might not suffice to find such relationships with custom-built rules especially from a large UMI graph containing a slew of edges. Building on this perspective, we set out to utilize Markov clustering (MCL)<sup>2</sup>, a graph-based clustering algorithm, to naturally and spontaneously discover subcomponents with high connectivity from a UMI graph. The MCL-based UMI collapsing process is briefly formulated as follows.</p> <p>mclUMI is a Markov clustering (MCL) network-based software suite comprising two modules of mcl-val and mcl-ed, for precisely localizing unique UMIs and thus removing PCR duplicates. Different from all established methods, our MCL-based methods initially allow UMI nodes to be merged spontaneously based only on the connectivity of edges created by a given edit distance in each of connected components of a UMI-structured graph.</p> <ol> <li> <p>Smith T, Heger A, Sudbery I. UMI-tools: modeling sequencing errors in Unique Molecular Identifiers to improve quantification accuracy. Genome Res [Internet]. 2017;27:491\u20139. Available from: http://genome.cshlp.org/content/27/3/491.abstract\u00a0\u21a9</p> </li> <li> <p>Azad A, Pavlopoulos GA, Ouzounis CA, Kyrpides NC, Bulu\u00e7 A. HipMCL: a high-performance parallel implementation of the Markov clustering algorithm for large-scale networks. Nucleic Acids Res [Internet]. 2018;46:e33\u2013e33. Available from: https://doi.org/10.1093/nar/gkx1313\u00a0\u21a9</p> </li> </ol>"}]}