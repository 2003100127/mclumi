`tresor.gene.library` is the module that can simulate sequencing libraries at the bulk RNA-seq level. This is used to simulate reads that are tagged by genes, respectively.

# Usage

## 1. Python

### 1.1 Command

=== "MCL"

    ``` py linenums="1"
    import mclumi as mu
    
    df_mcl = mu.multipos.mcl(
        bam_fpn=to('data/example_bundle.bam'),
        ed_thres=1,
        pos_tag='PO',
        work_dir=to('data/'),
        verbose=False,  # False True

        heterogeneity=False,  # False True

        inflat_val=1.6,
        exp_val=2,
        iter_num=100,
    )

    print(df_mcl)

    ```

=== "MCL-val"

    ``` py linenums="1"
    import mclumi as mu
    
    df_mcl_val = mu.multipos.mcl_val(
        bam_fpn=to('data/example_bundle.bam'),
        ed_thres=1,
        pos_tag='PO',
        work_dir=to('data/'),
        verbose=False,  # False True

        heterogeneity=False,  # False True

        mcl_fold_thres=1.5,
        inflat_val=1.6,
        exp_val=2,
        iter_num=100,
    )

    print(df_mcl_val)

    ```

=== "MCL-ed"

    ``` py linenums="1"
    import mclumi as mu
    
    df_mcl_ed = mu.multipos.mcl_ed(
        bam_fpn=to('data/example_bundle.bam'),
        ed_thres=1,
        pos_tag='PO',
        work_dir=to('data/'),
        verbose=False,  # False True

        heterogeneity=False,  # False True

        mcl_fold_thres=1.5,
        inflat_val=1.6,
        exp_val=2,
        iter_num=100,
    )

    print(df_mcl_ed)
    ```

=== "Unique"

    ``` py linenums="1"
    import mclumi as mu
    
    df_unique = mu.multipos.unique(
        bam_fpn=to('data/example_bundle.bam'),
        ed_thres=1,
        pos_tag='PO',
        work_dir=to('data/'),
        verbose=False,  # False True

        heterogeneity=False,  # False True
    )
    print(df_unique)
    
    ```

=== "Cluster"

    ``` py linenums="1"
    import mclumi as mu
    
    df_cluster = mu.multipos.cluster(
        bam_fpn=to('data/example_bundle.bam'),
        ed_thres=1,
        pos_tag='PO',
        work_dir=to('data/'),
        verbose=False,  # False True

        heterogeneity=False,  # False True
    )
    print(df_cluster)

    ```

=== "Adjacency"

    ``` py linenums="1"
    import mclumi as mu
    
    df_adjacency = mu.multipos.adjacency(
        bam_fpn=to('data/example_bundle.bam'),
        ed_thres=1,
        pos_tag='PO',
        work_dir=to('data/'),
        verbose=False,  # False True

        heterogeneity=False,  # False True
    )
    print(df_adjacency)

    ```

=== "Directional"

    ``` py linenums="1"
    import mclumi as mu
    
    df_directional = mu.multipos.directional(
        bam_fpn=to('data/example_bundle.bam'),
        ed_thres=1,
        pos_tag='PO',
        work_dir=to('data/'),
        verbose=False,  # False True

        heterogeneity=False,  # False True
    )
    print(df_directional)

    ```

### 1.2 Attributes in the YAML file

!!! Illustration

    | Attribute      | Description                          |
    | :---------- | :----------------------------------- |
    | `ed_thres` | edit distance |
    | `pos_tag` | the tag to denote from which genomic position/locus a read is observed. For example, `mclumi.prep.umi_tools` function outputs reads whose positions are tagged with `PO` |
    | `bam_fpn` | input file in the BAM format |
    | `heterogeneity` | mode to indicate if studying trajectories of UMI origins and copies/derivatives across a series of PCR amplication cycles. If `heterogeneity` is set to `True`, users will gain more statistics and files in the final output directory |
    | `inflat_val` | inflation parameter of the Markov Clustering algorithm |
    | `exp_val` | expansion parameter of the Markov Clustering algorithm |
    | `iter_num` | number of interations for the Markov Clustering algorithm to converge |
    | `mcl_fold_thres` | a fold change threshold for MCL at a range of (1, `l`) where `l` is the length of a UMI. This parameter is placed when the `mcl_ed` or `mcl_val` function is used. |
    | `verbose` | whether to print intermediate results |
        

## 2. Shell

### 2.1 Command

``` c++ linenums="1"
mclumi loci \
-m mcl \
-ed 1  \
-pfpn ./mclumi/data/params.yml \
-bfpn ./mclumi/data/example_bundle.bam \
-wd ./mclumi/data/ \
-vb True
```

### 2.2 Command attributes

!!! Illustration

    | Attribute      | Description                          |
    | :---------- | :----------------------------------- |
    | `-m` | UMI deduplication method |
    | `-ed` | edit distance |
    | `-pfpn` | YAML parameter file. Please see the **`YAML`** tab for parameter details |
    | `-bfpn` | input file in the BAM format |
    | `-wd` | working directory |
    | `-vb` | whether to print intermediate results |


### 2.3 YAML file configuration

``` yaml
work_dir: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/

# bam_fpn: /mnt/d/Document/Programming/Python/mclumi/mclumi/data/example_bundle.bam

tag:
  # loci
  pos_tag: PO

  # bulk or single-cell
  gene_assigned_tag: XT
  gene_is_assigned_tag: XS

umi:
  ed_thres: 1

dedup:
  # mcl_val
  mcl_fold_thres: 1.
  inflat_val: 1.1
  exp_val: 2
  iter_num: 100

  # mcl_ed
  mcl_fold_thres: 1.6
  inflat_val: 1.1
  exp_val: 2
  iter_num: 100

#  dbscan_eps: 1.5
#  dbscan_min_spl: 1
#  birch_thres: 1.8
#  birch_n_clusters: None
#  hdbscan_min_spl: 3
```

### 2.4 Attributes in the YAML file

!!! Illustration

    | Attribute      | Description                          |
    | :---------- | :----------------------------------- |
    | `ed_thres` | edit distance |
    | `gene_assigned_tag` | to enable deduplication on the gene tag (XT recommended). Any other tag if you know what tags the reads in your provided BAM file. |
    | `gene_is_assigned_tag` | to check if reads are assigned the gene tag (XS recommended) |
    | `pos_tag` | the tag to denote from which genomic position/locus a read is observed. For example, `mclumi.prep.umi_tools` function outputs reads whose positions are tagged with `PO` |
    | `inflat_val` | inflation parameter of the Markov Clustering algorithm |
    | `exp_val` | expansion parameter of the Markov Clustering algorithm |
    | `iter_num` | number of interations for the Markov Clustering algorithm to converge |
    | `mcl_fold_thres` | a fold change threshold for MCL at a range of (1, `l`) where `l` is the length of a UMI. This parameter is placed when the `mcl_ed` or `mcl_val` function is used. |

# Output
## Console
``` py
                   ____  ____  _______
   ____ ___  _____/ / / / /  |/  /  _/
  / __ `__ \/ ___/ / / / / /|_/ // /  
 / / / / / / /__/ / /_/ / /  / // /   
/_/ /_/ /_/\___/_/\____/_/  /_/___/   
                                      

26/07/2024 16:47:09 logger: ===>You are using method MCL to deduplicate UMIs observed at multiple genomic loci.
26/07/2024 16:47:09 logger: ===>reading the bam file... /mnt/d/Document/Programming/Python/mclumi/mclumi/data/example_bundle.bam
26/07/2024 16:47:09 logger: ===>reading BAM time: 0.00s
26/07/2024 16:47:09 logger: =========>start converting bam to df...
26/07/2024 16:47:17 logger: =========>time to df: 7.347s
26/07/2024 16:47:17 logger: ======># of raw reads: 1175027
26/07/2024 16:47:17 logger: ======># of reads with qualified chrs: 1175027
26/07/2024 16:47:17 logger: ======># of unique umis: 1949
26/07/2024 16:47:17 logger: ======># of redundant umis: 1175027
26/07/2024 16:47:17 logger: ======>edit distance thres: 1
26/07/2024 16:47:17 logger: ======># of columns in the bam df: 14
26/07/2024 16:47:17 logger: ======>Columns in the bam df: ['id', 'query_name', 'flag', 'reference_id', 'genome_pos', 'mapping_quality', 'cigar', 'query_sequence', 'next_reference_id', 'next_reference_start', 'query_qualities', 'read', 'PO', 'umi']
26/07/2024 16:47:17 logger: ======># of raw reads:
              id                     query_name  ...     PO        umi
0              0  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA
1              1  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA
2              2  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA
3              3  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA
4              4  SRR2057595.11715337_ACCGGTTTA  ...      0  ACCGGTTTA
...          ...                            ...  ...    ...        ...
1175022  1175022   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG
1175023  1175023   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG
1175024  1175024   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG
1175025  1175025   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG
1175026  1175026   SRR2057595.8512200_ACCGGTTGG  ...  12046  ACCGGTTGG

[1175027 rows x 14 columns]
26/07/2024 16:47:17 logger: ===>start building umi graphs...
26/07/2024 16:47:36 logger: ===>time for building umi graphs: 18.15s
0                           {0: [0]}
1                           {0: [0]}
2                           {0: [0]}
3                        {0: [0, 1]}
4                           {0: [0]}
                    ...             
12042                       {0: [0]}
12043                       {0: [0]}
12044    {0: [0], 1: [1], 2: [2, 3]}
12045            {0: [0, 1], 1: [2]}
12046               {0: [0], 1: [1]}
Name: mcl, Length: 12047, dtype: object
===>Analysis has been complete and results have been saved!
                                                vignette  ...                  mcl_bam_ids
0      {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                          [0]
1      {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                         [74]
2      {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                         [75]
3      {'graph_adj': {0: [1], 1: [0]}, 'int_to_umi_di...  ...                         [76]
4      {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                        [351]
...                                                  ...  ...                          ...
12042  {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                    [1174155]
12043  {'graph_adj': {0: []}, 'int_to_umi_dict': {0: ...  ...                    [1174641]
12044  {'graph_adj': {0: [], 1: [], 2: [3], 3: [2]}, ...  ...  [1174642, 1174712, 1174760]
12045  {'graph_adj': {0: [1], 1: [0], 2: []}, 'int_to...  ...           [1174888, 1175019]
12046  {'graph_adj': {0: [], 1: []}, 'int_to_umi_dict...  ...           [1175021, 1175022]

[12047 rows x 12 columns]
```

## Understanding files
The resultant files of the simulated sequencing library are shown in the following picture.

<figure markdown="span">
  ![Image title](../../img/slib/gene/lib_random_content.jpg){ width="800" }
  <figcaption><strong>Fig</strong> 1. Generated files of a sequencing library</figcaption>
</figure>

!!! info "Annotation"

    For speeding up computation, we simulated the library for sample 0, which has genes 3, 4, and 5.

    * ***seq_s_0_g_3.txt*** - sequences for sample 0 and gene 3
    * ***umi_s_0_g_3.txt*** - UMIs for sample 0 and gene 3
    * ***cdna_ids_alone_s_0_g_3.txt*** - cDNA IDs for sample 0 and gene 3

In this case, we used homotrimer blocks to simulate UMIs where the length of each UMI is set to be 36 containing 12 trimer blocks.

<figure markdown="span">
  ![Image title](../../img/slib/gene/umi.jpg){ width="800" }
  <figcaption><strong>Fig</strong> 2. Simulated UMIs</figcaption>
</figure>

The sequences are randomly chosen from the input human cDNAs and truncated according to the length of each short read. 
<figure markdown="span">
  ![Image title](../../img/slib/gene/seq.jpg){ width="800" }
  <figcaption><strong>Fig</strong> 3. Simulated genomics sequences</figcaption>
</figure>

The sequencing library is tabulated to a dataframe. Each row shows the necessary information about the read 1

1. Sequence
2. Identifier
3. Source

!!! note "Attention"

    The identifier is composed of ID of the molecule, character `s` for sample, ID of the sample, character `g` for gene, and ID of the gene, demarked by *.

Init means a read 1 is a sequence from the sequencing library, to differ from those from PCR amplification.

<figure markdown="span">
  ![Image title](../../img/slib/gene/seq_lib.jpg){ width="800" }
  <figcaption><strong>Fig</strong> 4. Simulated sequencing library</figcaption>
</figure>

For sample 0, the chosen gene symbols of gene 3 are recorded, which correspond to the taken truncated sequences by order.
<figure markdown="span">
  ![Image title](../../img/slib/gene/cdna_ids.jpg){ width="800" }
  <figcaption><strong>Fig</strong> 5. Seeds for simulating cDNAs </figcaption>
</figure>